/* refs.c generated by valac 0.40.8, the Vala compiler
 * generated from refs.vala, do not modify */



#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>


#define TYPE_OBJ1 (obj1_get_type ())
#define OBJ1(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_OBJ1, Obj1))
#define OBJ1_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_OBJ1, Obj1Class))
#define IS_OBJ1(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_OBJ1))
#define IS_OBJ1_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_OBJ1))
#define OBJ1_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_OBJ1, Obj1Class))

typedef struct _Obj1 Obj1;
typedef struct _Obj1Class Obj1Class;
typedef struct _Obj1Private Obj1Private;
enum  {
	OBJ1_0_PROPERTY,
	OBJ1_NUM_PROPERTIES
};
static GParamSpec* obj1_properties[OBJ1_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_OBJ2 (obj2_get_type ())
#define OBJ2(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_OBJ2, Obj2))
#define OBJ2_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_OBJ2, Obj2Class))
#define IS_OBJ2(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_OBJ2))
#define IS_OBJ2_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_OBJ2))
#define OBJ2_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_OBJ2, Obj2Class))

typedef struct _Obj2 Obj2;
typedef struct _Obj2Class Obj2Class;
typedef struct _Obj2Private Obj2Private;
enum  {
	OBJ2_0_PROPERTY,
	OBJ2_NUM_PROPERTIES
};
static GParamSpec* obj2_properties[OBJ2_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))

struct _Obj1 {
	GObject parent_instance;
	Obj1Private * priv;
	gchar* s;
};

struct _Obj1Class {
	GObjectClass parent_class;
};

struct _Obj2 {
	GObject parent_instance;
	Obj2Private * priv;
	Obj1* foobar;
};

struct _Obj2Class {
	GObjectClass parent_class;
};


static gpointer obj1_parent_class = NULL;
static gpointer obj2_parent_class = NULL;

GType obj1_get_type (void) G_GNUC_CONST;
Obj1* obj1_new (const gchar* s);
Obj1* obj1_construct (GType object_type,
                      const gchar* s);
static void obj1_finalize (GObject * obj);
GType obj2_get_type (void) G_GNUC_CONST;
Obj2* obj2_new (Obj1* o);
Obj2* obj2_construct (GType object_type,
                      Obj1* o);
static void obj2_finalize (GObject * obj);
void _vala_main (void);


Obj1*
obj1_construct (GType object_type,
                const gchar* s)
{
	Obj1 * self = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (s != NULL, NULL);
	self = (Obj1*) g_object_new (object_type, NULL);
	_tmp0_ = g_strdup (s);
	_g_free0 (self->s);
	self->s = _tmp0_;
	return self;
}


Obj1*
obj1_new (const gchar* s)
{
	return obj1_construct (TYPE_OBJ1, s);
}


static void
obj1_class_init (Obj1Class * klass)
{
	obj1_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = obj1_finalize;
}


static void
obj1_instance_init (Obj1 * self)
{
}


static void
obj1_finalize (GObject * obj)
{
	Obj1 * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_OBJ1, Obj1);
	_g_free0 (self->s);
	G_OBJECT_CLASS (obj1_parent_class)->finalize (obj);
}


GType
obj1_get_type (void)
{
	static volatile gsize obj1_type_id__volatile = 0;
	if (g_once_init_enter (&obj1_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (Obj1Class), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) obj1_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Obj1), 0, (GInstanceInitFunc) obj1_instance_init, NULL };
		GType obj1_type_id;
		obj1_type_id = g_type_register_static (G_TYPE_OBJECT, "Obj1", &g_define_type_info, 0);
		g_once_init_leave (&obj1_type_id__volatile, obj1_type_id);
	}
	return obj1_type_id__volatile;
}


static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}


Obj2*
obj2_construct (GType object_type,
                Obj1* o)
{
	Obj2 * self = NULL;
	Obj1* _tmp0_;
	g_return_val_if_fail (o != NULL, NULL);
	self = (Obj2*) g_object_new (object_type, NULL);
	_tmp0_ = _g_object_ref0 (o);
	_g_object_unref0 (self->foobar);
	self->foobar = _tmp0_;
	return self;
}


Obj2*
obj2_new (Obj1* o)
{
	return obj2_construct (TYPE_OBJ2, o);
}


static void
obj2_class_init (Obj2Class * klass)
{
	obj2_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = obj2_finalize;
}


static void
obj2_instance_init (Obj2 * self)
{
}


static void
obj2_finalize (GObject * obj)
{
	Obj2 * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_OBJ2, Obj2);
	_g_object_unref0 (self->foobar);
	G_OBJECT_CLASS (obj2_parent_class)->finalize (obj);
}


GType
obj2_get_type (void)
{
	static volatile gsize obj2_type_id__volatile = 0;
	if (g_once_init_enter (&obj2_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (Obj2Class), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) obj2_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Obj2), 0, (GInstanceInitFunc) obj2_instance_init, NULL };
		GType obj2_type_id;
		obj2_type_id = g_type_register_static (G_TYPE_OBJECT, "Obj2", &g_define_type_info, 0);
		g_once_init_leave (&obj2_type_id__volatile, obj2_type_id);
	}
	return obj2_type_id__volatile;
}


static gchar*
g_file_stream_read_line (FILE* self)
{
	gchar* result = NULL;
	gint c = 0;
	GString* ret = NULL;
	GString* _tmp6_;
	g_return_val_if_fail (self != NULL, NULL);
	ret = NULL;
	while (TRUE) {
		gint _tmp0_;
		GString* _tmp1_;
		gint _tmp3_;
		GString* _tmp4_;
		gint _tmp5_;
		c = fgetc (self);
		_tmp0_ = c;
		if (!(_tmp0_ != EOF)) {
			break;
		}
		_tmp1_ = ret;
		if (_tmp1_ == NULL) {
			GString* _tmp2_;
			_tmp2_ = g_string_new ("");
			_g_string_free0 (ret);
			ret = _tmp2_;
		}
		_tmp3_ = c;
		if (_tmp3_ == ((gint) '\n')) {
			break;
		}
		_tmp4_ = ret;
		_tmp5_ = c;
		g_string_append_c ((GString*) _tmp4_, (gchar) _tmp5_);
	}
	_tmp6_ = ret;
	if (_tmp6_ == NULL) {
		result = NULL;
		_g_string_free0 (ret);
		return result;
	} else {
		GString* _tmp7_;
		const gchar* _tmp8_;
		gchar* _tmp9_;
		_tmp7_ = ret;
		_tmp8_ = ((GString*) _tmp7_)->str;
		_tmp9_ = g_strdup (_tmp8_);
		result = _tmp9_;
		_g_string_free0 (ret);
		return result;
	}
	_g_string_free0 (ret);
}


void
_vala_main (void)
{
	Obj2* o = NULL;
	FILE* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	Obj1* _tmp3_;
	Obj1* _tmp4_;
	Obj2* _tmp5_;
	Obj2* _tmp6_;
	FILE* _tmp7_;
	Obj1* _tmp8_;
	const gchar* _tmp9_;
	_tmp0_ = stdin;
	_tmp1_ = g_file_stream_read_line (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = obj1_new (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = obj2_new (_tmp4_);
	_tmp6_ = _tmp5_;
	_g_object_unref0 (_tmp4_);
	_g_free0 (_tmp2_);
	o = _tmp6_;
	_tmp7_ = stdout;
	_tmp8_ = o->foobar;
	_tmp9_ = _tmp8_->s;
	fprintf (_tmp7_, "%s\n", _tmp9_);
	_g_object_unref0 (o);
}


int
main (int argc,
      char ** argv)
{
	_vala_main ();
	return 0;
}



